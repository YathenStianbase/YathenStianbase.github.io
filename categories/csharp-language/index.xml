<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CSharp Language on Paradoxical</title>
    <link>https://yathenstianbase.github.io/categories/csharp-language/</link>
    <description>Recent content in CSharp Language on Paradoxical</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://yathenstianbase.github.io/categories/csharp-language/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Accessibility Levels in C# [C#可访问级别]</title>
      <link>https://yathenstianbase.github.io/posts/csharp/accessibility-levels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yathenstianbase.github.io/posts/csharp/accessibility-levels/</guid>
      <description>访问修饰符 public - 全局访问，可跨程序集; private - 只能由包含类访问; protected - 只能由包含类和包含类的继承类访问; internal - 只能由当前程序集访问; sealed - 不属于访问修饰符，表示一个类不可被继承; protected internal - 可被其他程序集中的派生类所访问; namespace Assembly1 { public class Greet { protected internal string msg=&amp;#34;Hello&amp;#34;; } class Program { static void Main(string[] args) { Greet greet = new Greet(); Console.WriteLine(greet.msg); Console.ReadLine(); } } } // access Assembly1 using Assembly1; namespace Assembly2 { // derived class of Greet class Program: Greet { static void Main(string[] args) { Program greet = new Program(); // 此处可以跨程序集访问&amp;#34;protected internal&amp;#34;修饰的变量 msg Console.</description>
    </item>
    
    <item>
      <title>C# Ref type [C#引用类型]</title>
      <link>https://yathenstianbase.github.io/posts/csharp/csharp-ref-type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yathenstianbase.github.io/posts/csharp/csharp-ref-type/</guid>
      <description>引用类型的变量存储对其数据（对象）的引用，而值类型的变量直接包含其数据。 对于引用类型，两种变量可引用同一对象；因此，对一个变量执行的操作会影响另一个变量所引用的对象。 对于值类型，每个变量都具有其自己的数据副本，对一个变量执行的操作不会影响另一个变量（in、ref 和 out 参数变量除外；请参阅 in、ref 和 out 参数修饰符）。
引用类型声明关键字：
class interface delegate record 内置引用类型
动态类型; dynamic 类型表示变量的使用和对其成员的引用绕过编译时类型检查。 改为在运行时解析这些操作; 对象类型; object 类型是 System.Object 在 .NET 中的别名; 字符串类型; string 类型表示零个或多个 Unicode 字符的序列。 string 是 System.String 在 .NET 中的别名; 委托类型; 在 .NET 中，System.Action 和 System.Func 类型为许多常见委托提供泛型定义；委托可以被实例化; 枚举类型本身为值类型，但是.NET提供了System.Enum类，所以枚举中会有一个静态方法Enum.ToObject()用于做转换;
Ref:
[引用类型定义](&amp;gt; https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/reference-types)
结构体和类的区别</description>
    </item>
    
    <item>
      <title>C# Value type [C#值类型]</title>
      <link>https://yathenstianbase.github.io/posts/csharp/csharp-value-type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yathenstianbase.github.io/posts/csharp/csharp-value-type/</guid>
      <description>值类型的变量包含类型的实例; 在内存分配上，值类型可以存储再栈和堆中，引用类型存储在堆上; 默认情况下，在分配中，通过将实参传递给方法并返回方法结果来复制变量值。 对于值类型变量，会复制相应的类型实例; 值类型在继承体系中由ValueType类表示; 值类型保存的数据在传递前后是独立的;
// 伪码 int val = 3.14f; 传递进方法 change(int val) { val += 1.00f； print(val); // 第一次打印为 4.14 } print(val); // 第二次打印为 3.14 值类型的种类
C# 提供以下内置值类型，也称为“简单类型”,所有简单值都是结构类型： 整型数值类型 &amp;mdash; .NET类型
sbyte &amp;mdash; System.Sbyte byte &amp;mdash; System.Byte short &amp;mdash; System.Int16 ushort &amp;mdash; System.Uint16 int &amp;mdash; System.Int32 uint &amp;mdash; System.UInt32 long &amp;mdash; System.Int64 ulong &amp;mdash; System.UInt64 nint &amp;mdash; System.IntPtr nuint &amp;mdash; System.UIntPtr 浮点型数值类型 - .NET类型
float System.Single double System.</description>
    </item>
    
  </channel>
</rss>
